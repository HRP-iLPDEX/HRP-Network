use common::DAI;
use common::PSWAP;
use common::VAL;
use ethereum_types::H160;

use super::mock::{ExtBuilder, Runtime};
use crate::requests::*;
use crate::{
    BridgeSignatureVersion, BridgeSignatureVersions, RegisteredAsset, RegisteredSidechainToken,
};
use bridge_multisig::{BridgeTimepoint, MultiChainHeight};
use rustc_hex::ToHex;

fn assert_hex(bytes: &[u8], expected: &str) {
    assert_eq!(bytes.to_hex::<String>(), expected);
}

#[test]
fn should_encode_old_transfer() {
    let (mut ext, _state) = ExtBuilder::default().build();

    ext.execute_with(|| {
        let request = OutgoingTransfer::<Runtime> {
            from: [1u8; 32].into(),
            to: [2u8; 20].into(),
            asset_id: VAL,
            amount: 121213,
            nonce: 12,
            network_id: 0,
            timepoint: BridgeTimepoint {
                height: MultiChainHeight::Thischain(12),
                index: 13,
            },
        };
        let encoded = request.to_eth_abi([3u8; 32].into()).unwrap();
        assert_hex(&encoded.raw, "3f9feac97e5feb15d8bf98042a9a01b515da3dfb000000000000000000000000000000000000000000000000000000000001d97d020202020202020202020202020202020202020203030303030303030303030303030303030303030303030303030303030303030101010101010101010101010101010101010101");
    });
}

#[test]
fn should_encode_thischain_transfer() {
    let (mut ext, _state) = ExtBuilder::default().build();

    ext.execute_with(|| {
        for (version, expected) in [
            (BridgeSignatureVersion::V1, "0200050000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001d97d0202020202020202020202020202020202020202010101010101010101010101010101010101010103030303030303030303030303030303030303030303030303030303030303030000000000000000000000000000000000000000000000000000000000000000"),
            (BridgeSignatureVersion::V2, "00000000000000000000000000000000000000000200050000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001d97d0202020202020202020202020202020202020202010101010101010101010101010101010101010103030303030303030303030303030303030303030303030303030303030303030000000000000000000000000000000000000000000000000000000000000000"),
            (BridgeSignatureVersion::V3, "000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000200050000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001d97d0000000000000000000000000202020202020202020202020202020202020202000000000000000000000000010101010101010101010101010101010101010103030303030303030303030303030303030303030303030303030303030303030000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000d7472616e736665724f776e656400000000000000000000000000000000000000"),
        ] {
            BridgeSignatureVersions::<Runtime>::insert(0, version);
            RegisteredAsset::<Runtime>::insert(0, PSWAP, AssetKind::Thischain);
            let request = OutgoingTransfer::<Runtime> {
                from: [1u8; 32].into(),
                to: [2u8; 20].into(),
                asset_id: PSWAP,
                amount: 121213,
                nonce: 12,
                network_id: 0,
                timepoint: BridgeTimepoint {
                    height: MultiChainHeight::Thischain(12),
                    index: 13,
                },
            };
            let encoded = request.to_eth_abi([3u8; 32].into()).unwrap();
            assert_hex(&encoded.raw, expected);
        }
    });
}

#[test]
fn should_encode_sidechain_transfer() {
    let (mut ext, _state) = ExtBuilder::default().build();

    ext.execute_with(|| {
        for (version, expected) in [
            (BridgeSignatureVersion::V1, "0404040404040404040404040404040404040404000000000000000000000000000000000000000000000000000000000001d97d0202020202020202020202020202020202020202010101010101010101010101010101010101010105050505050505050505050505050505050505050505050505050505050505050000000000000000000000000000000000000000000000000000000000000000"),
            (BridgeSignatureVersion::V2, "00000000000000000000000000000000000000000404040404040404040404040404040404040404000000000000000000000000000000000000000000000000000000000001d97d0202020202020202020202020202020202020202010101010101010101010101010101010101010105050505050505050505050505050505050505050505050505050505050505050000000000000000000000000000000000000000000000000000000000000000"),
            (BridgeSignatureVersion::V3, "000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000404040404040404040404040404040404040404000000000000000000000000000000000000000000000000000000000001d97d0000000000000000000000000202020202020202020202020202020202020202000000000000000000000000010101010101010101010101010101010101010105050505050505050505050505050505050505050505050505050505050505050000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000d7472616e736665724f776e656400000000000000000000000000000000000000"),
        ] {
            BridgeSignatureVersions::<Runtime>::insert(0, version);
            RegisteredAsset::<Runtime>::insert(0, DAI, AssetKind::Thischain);
            RegisteredSidechainToken::<Runtime>::insert(0, DAI, H160::from([4u8; 20]));
            let request = OutgoingTransfer::<Runtime> {
                from: [1u8; 32].into(),
                to: [2u8; 20].into(),
                asset_id: DAI,
                amount: 121213,
                nonce: 12,
                network_id: 0,
                timepoint: BridgeTimepoint {
                    height: MultiChainHeight::Thischain(12),
                    index: 13,
                },
            };
            let encoded = request.to_eth_abi([5u8; 32].into()).unwrap();
            assert_hex(&encoded.raw, expected);
        }
    });
}

#[test]
fn should_encode_add_peer() {
    let (mut ext, _state) = ExtBuilder::default().build();

    ext.execute_with(|| {
        for (version, expected) in [
            (BridgeSignatureVersion::V1, "020202020202020202020202020202020202020204040404040404040404040404040404040404040404040404040404040404040000000000000000000000000000000000000000000000000000000000000000"),
            (BridgeSignatureVersion::V2, "000000000000000000000000000000000000000061646450656572020202020202020202020202020202020202020204040404040404040404040404040404040404040404040404040404040404040000000000000000000000000000000000000000000000000000000000000000"),
            (BridgeSignatureVersion::V3, "00000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002020202020202020202020202020202020202020404040404040404040404040404040404040404040404040404040404040404000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000076164645065657200000000000000000000000000000000000000000000000000"),
        ] {
            BridgeSignatureVersions::<Runtime>::insert(0, version);
            let request = OutgoingAddPeer::<Runtime> {
                author: [1u8; 32].into(),
                peer_address: [2u8; 20].into(),
                peer_account_id: [3u8; 32].into(),
                nonce: 1213,
                network_id: 0,
                timepoint: BridgeTimepoint {
                    height: MultiChainHeight::Thischain(12),
                    index: 13,
                },
            };
            let encoded = request.to_eth_abi([4u8; 32].into()).unwrap();
            assert_hex(&encoded.raw, expected);
        }
    });
}

#[test]
fn should_encode_remove_peer() {
    let (mut ext, _state) = ExtBuilder::default().build();

    ext.execute_with(|| {
        for (version, expected) in [
            (BridgeSignatureVersion::V1, "020202020202020202020202020202020202020204040404040404040404040404040404040404040404040404040404040404040000000000000000000000000000000000000000000000000000000000000000"),
            (BridgeSignatureVersion::V2, "000000000000000000000000000000000000000072656d6f766550656572020202020202020202020202020202020202020204040404040404040404040404040404040404040404040404040404040404040000000000000000000000000000000000000000000000000000000000000000"),
            (BridgeSignatureVersion::V3, "00000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020202020202020202020202020202020202020204040404040404040404040404040404040404040404040404040404040404040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a72656d6f76655065657200000000000000000000000000000000000000000000"),
        ] {
            BridgeSignatureVersions::<Runtime>::insert(0, version);
            let request = OutgoingRemovePeer::<Runtime> {
                author: [1u8; 32].into(),
                peer_address: [2u8; 20].into(),
                peer_account_id: [3u8; 32].into(),
                nonce: 1213,
                network_id: 0,
                timepoint: BridgeTimepoint {
                    height: MultiChainHeight::Thischain(12),
                    index: 13,
                },
                compat_hash: None,
            };
            let encoded = request.to_eth_abi([4u8; 32].into()).unwrap();
            assert_hex(&encoded.raw, expected);
        }
    });
}

#[test]
fn should_encode_add_peer_compat() {
    let (mut ext, _state) = ExtBuilder::default().build();

    ext.execute_with(|| {
        let request = OutgoingAddPeerCompat::<Runtime> {
            author: [1u8; 32].into(),
            peer_address: [2u8; 20].into(),
            peer_account_id: [3u8; 32].into(),
            nonce: 1213,
            network_id: 0,
            timepoint: BridgeTimepoint {
                height: MultiChainHeight::Thischain(12),
                index: 13,
            },
        };
        let encoded = request.to_eth_abi([4u8; 32].into()).unwrap();
        assert_hex(&encoded.raw, "00000000000000000000000002020202020202020202020202020202020202020404040404040404040404040404040404040404040404040404040404040404");
    });
}

#[test]
fn should_encode_remove_peer_compat() {
    let (mut ext, _state) = ExtBuilder::default().build();

    ext.execute_with(|| {
        let request = OutgoingRemovePeerCompat::<Runtime> {
            author: [1u8; 32].into(),
            peer_address: [2u8; 20].into(),
            peer_account_id: [3u8; 32].into(),
            nonce: 1213,
            network_id: 0,
            timepoint: BridgeTimepoint {
                height: MultiChainHeight::Thischain(12),
                index: 13,
            },
        };
        let encoded = request.to_eth_abi([4u8; 32].into()).unwrap();
        assert_hex(&encoded.raw, "02020202020202020202020202020202020202020404040404040404040404040404040404040404040404040404040404040404");
    });
}

#[test]
fn should_encode_add_token() {
    let (mut ext, _state) = ExtBuilder::default().build();

    ext.execute_with(|| {
        for (version, expected) in [
            (BridgeSignatureVersion::V1, "020202020202020202020202020202020202020244414955534420446f6c6c61721203030303030303030303030303030303030303030303030303030303030303030000000000000000000000000000000000000000000000000000000000000000"),
            (BridgeSignatureVersion::V2, "0000000000000000000000000000000000000000020202020202020202020202020202020202020244414955534420446f6c6c61721203030303030303030303030303030303030303030303030303030303030303030000000000000000000000000000000000000000000000000000000000000000"),
            (BridgeSignatureVersion::V3, "000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000202020202020202020202020202020202020202000000000000000000000000000000000000000000000000000000000000014000000000000000000000000000000000000000000000000000000000000001800000000000000000000000000000000000000000000000000000000000000012030303030303030303030303030303030303030303030303030303030303030300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008616464546f6b656e00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000034441490000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a55534420446f6c6c617200000000000000000000000000000000000000000000"),
        ] {
            BridgeSignatureVersions::<Runtime>::insert(0, version);
            let request = OutgoingAddToken::<Runtime> {
                author: [1u8; 32].into(),
                token_address: [2u8; 20].into(),
                symbol: "DAI".into(),
                name: "USD Dollar".into(),
                decimals: 18,
                nonce: 1213,
                network_id: 0,
                timepoint: BridgeTimepoint {
                    height: MultiChainHeight::Thischain(12),
                    index: 13,
                },
            };
            let encoded = request.to_eth_abi([3u8; 32].into()).unwrap();
            assert_hex(&encoded.raw, expected);
        }
    });
}

#[test]
fn should_encode_add_asset() {
    let (mut ext, _state) = ExtBuilder::default().build();

    ext.execute_with(|| {
        for (version, expected) in [
            (BridgeSignatureVersion::V1, "00020006000000000000000000000000000000000000000000000000000000000003030303030303030303030303030303030303030303030303030303030303030000000000000000000000000000000000000000000000000000000000000000"),
            (BridgeSignatureVersion::V2, "000000000000000000000000000000000000000000020006000000000000000000000000000000000000000000000000000000000003030303030303030303030303030303030303030303030303030303030303030000000000000000000000000000000000000000000000000000000000000000"),
            (BridgeSignatureVersion::V3, "000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000140000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000000000200060000000000000000000000000000000000000000000000000000000000030303030303030303030303030303030303030303030303030303030303030300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008616464417373657400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
        ] {
            BridgeSignatureVersions::<Runtime>::insert(0, version);
            let request = OutgoingAddAsset::<Runtime> {
                author: [1u8; 32].into(),
                asset_id: DAI,
                nonce: 1213,
                network_id: 0,
                timepoint: BridgeTimepoint {
                    height: MultiChainHeight::Thischain(12),
                    index: 13,
                },
            };
            let encoded = request.to_eth_abi([3u8; 32].into()).unwrap();
            assert_hex(&encoded.raw, expected);
        }
    });
}

#[test]
fn should_encode_prepare_for_migration() {
    let (mut ext, _state) = ExtBuilder::default().build();

    ext.execute_with(|| {
        for (version, expected) in [
            (BridgeSignatureVersion::V1, "000000000000000000000000000000000000000003030303030303030303030303030303030303030303030303030303030303030000000000000000000000000000000000000000000000000000000000000000"),
            (BridgeSignatureVersion::V2, "707265706172654d6967726174696f6e000000000000000000000000000000000000000003030303030303030303030303030303030303030303030303030303030303030000000000000000000000000000000000000000000000000000000000000000"),
            (BridgeSignatureVersion::V3, "00000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000000030303030303030303030303030303030303030303030303030303030303030300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010707265706172654d6967726174696f6e00000000000000000000000000000000"),
        ] {
            BridgeSignatureVersions::<Runtime>::insert(0, version);
            let request = OutgoingPrepareForMigration::<Runtime> {
                author: [1u8; 32].into(),
                nonce: 1213,
                network_id: 0,
                timepoint: BridgeTimepoint {
                    height: MultiChainHeight::Thischain(12),
                    index: 13,
                },
            };
            let encoded = request.to_eth_abi([3u8; 32].into()).unwrap();
            assert_hex(&encoded.raw, expected);
        }
    });
}

#[test]
fn should_encode_migrate() {
    let (mut ext, _state) = ExtBuilder::default().build();

    ext.execute_with(|| {
        for (version, expected) in [
            (BridgeSignatureVersion::V1, "0000000000000000000000000000000000000000060606060606060606060606060606060606060605050505050505050505050505050505050505050505050505050505050505050000000000000000000000000202020202020202020202020202020202020202000000000000000000000000030303030303030303030303030303030303030300000000000000000000000004040404040404040404040404040404040404040000000000000000000000000000000000000000000000000000000000000000"),
            (BridgeSignatureVersion::V2, "0000000000000000000000000000000000000000060606060606060606060606060606060606060605050505050505050505050505050505050505050505050505050505050505050000000000000000000000000202020202020202020202020202020202020202000000000000000000000000030303030303030303030303030303030303030300000000000000000000000004040404040404040404040404040404040404040000000000000000000000000000000000000000000000000000000000000000"),
            (BridgeSignatureVersion::V3, "00000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000060606060606060606060606060606060606060605050505050505050505050505050505050505050505050505050505050505050000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000076d696772617465000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003000000000000000000000000020202020202020202020202020202020202020200000000000000000000000003030303030303030303030303030303030303030000000000000000000000000404040404040404040404040404040404040404"),
        ] {
            BridgeSignatureVersions::<Runtime>::insert(0, version);
            let request = OutgoingMigrate::<Runtime> {
                author: [1u8; 32].into(),
                new_contract_address: [6u8; 20].into(),
                erc20_native_tokens: vec![[2u8; 20].into(), [3u8; 20].into(), [4u8; 20].into()],
                nonce: 1213,
                network_id: 0,
                timepoint: BridgeTimepoint {
                    height: MultiChainHeight::Thischain(12),
                    index: 13,
                },
                new_signature_version: BridgeSignatureVersion::V3,
            };
            let encoded = request.to_eth_abi([5u8; 32].into()).unwrap();
            assert_hex(&encoded.raw, expected);
        }
    });
}
